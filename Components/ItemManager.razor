@inject Blazored.LocalStorage.ILocalStorageService localStore
@implements IDisposable

<p>
    <select
        class="selectpicker"
        @bind="_currentItem.Type">
            <option value="@Item.ItemType.Note">Note</option>
            <option value="@Item.ItemType.Slider">Slider</option>
    </select>

    <input
        type="text"
        placeholder="Title"
        @bind="_currentItem.Title" />
    <input
        type="text"
        placeholder="Description"
        @bind="_currentItem.Description" />

    <button
        class="btn btn-primary"
        @onclick="AddItem">
            Add
    </button>
    <button
        class="btn btn-primary"
        @onclick="RemoveAllItems">
            Clear
    </button>
</p>

@code {
    private int _currentItemId;
    private Item _currentItem;

    public static event Action RemovedAllItems;
    // Action<> perhaps instead of EventHandler? (I don't think so)
    public static event EventHandler<ItemAddedEventArgs<Item>> ItemAdded;
    public ItemAddedEventArgs<Item> ItemAddedEventArgs;

    protected override async Task OnInitializedAsync()
    {
        InitializeCurrentItem();
        Main.RemovedItem += MainOnRemovedItem;
        _currentItemId = await localStore.LengthAsync();
    }
    private async void AddItem()
    {
        for (int i = 0; i < await localStore.LengthAsync(); i++)
        {
            // TODO: error handling
            if (_currentItem.Title == (await GetItem(i)).Title) return;
        }

        _currentItem.ItemId = _currentItemId;
        _currentItem.Created = _currentItem.Updated = DateTime.Now;

        await localStore.SetItemAsync<Item>(_currentItemId.ToString(), _currentItem);

        ItemAddedEventArgs = new ItemAddedEventArgs<Item>(_currentItem);
        ItemAdded?.Invoke(this, ItemAddedEventArgs);

        _currentItemId++;
        InitializeCurrentItem();

        StateHasChanged();
    }

    private async void RemoveAllItems()
    {
        await localStore.ClearAsync();

        _currentItemId = 0;

        RemovedAllItems?.Invoke();
    }

    public async void MainOnRemovedItem(object sender, int itemId)
    {
        await localStore.RemoveItemAsync(itemId.ToString());
        int storeLength = await localStore.LengthAsync();

        // slow spergy reordering is slow
        if (itemId < storeLength)
        {
            for (int i = itemId; i < storeLength; i++)
            {
                _currentItem = await localStore.GetItemAsync<Item>((i + 1).ToString());
                _currentItem.ItemId = i;
                await localStore.SetItemAsync<Item>(i.ToString(), _currentItem);
            }
            await localStore.RemoveItemAsync((storeLength).ToString());
        }

        _currentItemId = storeLength;
        InitializeCurrentItem();

        StateHasChanged();
    }

    private async Task<Item> GetItem(int itemId)
    {
        return await localStore.GetItemAsync<Item>(itemId.ToString());
    }

    private void InitializeCurrentItem()
    {
        _currentItem = new Item
                    {
                        ItemId = -1,
                        Title = "",
                        Description = "",
                        Value = 0.0f,
                        Notes = "",
                        Type = 0,
                        Created = DateTime.UnixEpoch,
                        Updated = DateTime.UnixEpoch
                    };
    }

    public void Dispose()
    {
        Main.RemovedItem -= MainOnRemovedItem;
    }
}